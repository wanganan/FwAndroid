使用技术：
Base,MVP,Kotlin,SmartRefreshLayout,BaseRecyclerViewAdapterHelper,Retrofit,RxJava,HTTPS安全认证,OkHttp无网缓存,RxLifecycle,Logger,
屏幕适配，全局字体改变，语言国际化，代码混淆，

——————————————————————————————————————————————————
>>>Kotlin：
https://kotlinlang.org/docs/reference/
https://developer.android.google.cn/kotlin
——————————————————————————————————————————————————
>>>Dagger：
https://dagger.dev/dev-guide/android.html
https://developer.android.google.cn/training/dependency-injection/dagger-android
——————————————————————————————————————————————————
>>>约束布局ConstraintLayout：https://www.jianshu.com/p/17ec9bd6ca8a
implementation 'com.android.support.constraint:constraint-layout:1.1.3'
——————————————————————————————————————————————————
>>>智能刷新库：https://github.com/scwang90/SmartRefreshLayout
如果使用 AndroidX 需要依赖 androidx.appcompat，Header依赖包建议需要使用哪个就复制哪个的源码到项目中。
implementation 'androidx.appcompat:appcompat:1.0.0'                 //必须 1.0.0 以上
implementation  'com.scwang.smart:refresh-layout-kernel:2.0.1'      //核心必须依赖
implementation  'com.scwang.smart:refresh-header-classics:2.0.1'    //经典刷新头
implementation  'com.scwang.smart:refresh-header-radar:2.0.1'       //雷达刷新头
implementation  'com.scwang.smart:refresh-header-falsify:2.0.1'     //虚拟刷新头
implementation  'com.scwang.smart:refresh-header-material:2.0.1'    //谷歌刷新头
implementation  'com.scwang.smart:refresh-header-two-level:2.0.1'   //二级刷新头
implementation  'com.scwang.smart:refresh-footer-ball:2.0.1'        //球脉冲加载
implementation  'com.scwang.smart:refresh-footer-classics:2.0.1'    //经典加载
并在 gradle.properties 中添加
android.useAndroidX=true
android.enableJetifier=true
SmartRefreshLayout 不需要添加混淆过滤代码，并且已经混淆测试通过
——————————————————————————————————————————————————
>>>强大灵活的RecyclerViewAdapter：https://github.com/CymChad/BaseRecyclerViewAdapterHelper
将JitPack存储库添加到您的构建文件中(项目根目录下build.gradle文件)
allprojects {
    repositories {
        ...
        maven { url 'https://jitpack.io' }
    }
}
添加依赖项
仅支持AndroidX
implementation 'com.github.CymChad:BaseRecyclerViewAdapterHelper:3.0.4'
此资源库自带混淆规则，并且会自动导入，正常情况下无需手动导入。
——————————————————————————————————————————————————
>>>Retrofit:
Retrofit requires at minimum Java 8+ or Android API 21+.
https://github.com/square/retrofit
https://github.com/square/okhttp
https://www.jianshu.com/p/360768def285
implementation 'com.squareup.retrofit2:retrofit:2.9.0'
implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
implementation 'com.squareup.retrofit2:converter-scalars:2.9.0'
implementation 'com.squareup.retrofit2:adapter-rxjava3:latest.version'
implementation 'com.squareup.okhttp3:logging-interceptor:4.7.2'
——————————————————————————————————————————————————
>>>RxJava：
https://github.com/ReactiveX/RxJava
http://reactivex.io/RxJava/3.x/javadoc/
https://github.com/ReactiveX/RxAndroid
RxJava3详细介绍：https://blog.csdn.net/h176nhx7/article/details/96054109
Flowable使用介绍：https://my.oschina.net/carbenson/blog/1002466
定义：是一个响应扩展的Java VM实现:一个通过使用可观察序列组合异步和基于事件的程序的库。(等同于Android中的 AsyncTask 、Handler作用)
特点：由于其基于事件流的链式调用、逻辑简洁 & 使用简单的特点，深受各大 Android开发者的欢迎。
原理：基于一种扩展的观察者模式
应用：常见用例是在后台线程上运行一些计算、网络请求，并在UI线程上显示结果(或错误)。
Flowable可看作是有背压的Observable。
implementation "io.reactivex.rxjava3:rxjava:3.0.4"
基础类：
io.reactivex.rxjava3.core.Flowable：0..N流量，支持反应流和背压
io.reactivex.rxjava3.core.Observable：0..N流动，无背压，
io.reactivex.rxjava3.core.Single：正好是1个项目的流或一个错误，
io.reactivex.rxjava3.core.Completable：没有项目但只有完成或错误信号的流程，
io.reactivex.rxjava3.core.Maybe：没有项目，恰好一项或错误的流程。
基础操作符：
Observable(被观察者，可观察对象，就是要进行什么操作，相当于生产者)
subscribe 负责处理事件，他是事件的消费者
Operator 是对 Observable 发出的事件进行修改和变换
subscribeOn(): 指定 subscribe() 所发生的线程
observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程
doOnEach：数据源（Observable）每发送一次数据，就调用一次。
doOnNext：数据源每次调用onNext() 之前都会先回调该方法。
doOnError：数据源每次调用onError() 之前会回调该方法。
doOnComplete：数据源每次调用onComplete() 之前会回调该方法
doOnSubscribe：数据源每次调用onSubscribe() 之后会回调该方法
doOnDispose：数据源每次调用dispose() 之后会回调该方法
Flowable背压：
当数据流通过异步步骤运行时，每一步可能以不同的速度执行不同的事情。这类步骤通常会由于临时缓冲或需要跳过/删除数据而导致内存使用量增加，
为了避免这些步骤过于庞大，应用了所谓的backpressure，这是一种流控制形式，其中步骤可以表示它们准备处理多少项。这允许在某些情况下限制数据流的内存使用。
Flowable类被指定为支持背压操作，而Observable类被指定为非背压操作(短序列、GUI交互等)。其他类型，Single, Maybe和Completable不支持背压，也不应该支持。
Flowable流：
source.operator1().operator2().operator3().subscribeOn(Schedulers.io()).observeOn(Schedulers.single()).subscribe(consumer)
如果我们想象自己在操作器上，向左看源称为上游。向右看订阅者/使用者称为下游。
可以通过subscribeOn将计算或阻塞IO移动到其他线程。一旦数据准备好了，就可以确保通过observeOn在前台或GUI线程上处理它们。
Flowable和Observable区别：
上下游：Flowable/Subscriber,Observable/Observer
被观察者：FlowableOnSubscribe,ObservableOnSubscribe
观察者：Subscriber,Observer
取消订阅：Subscription,Disposable
create()：create(FlowableOnSubscribe,BackpressureStrategy),create(ObservableOnSubscribe)//背压策略：BackpressureStrategy.MISSING、ERROR、DROP、LATEST
Schedulers调度器
RxJava操作符并不直接与线程或ExecutorServices一起工作，而是与所谓的调度器一起工作，这些调度器抽象出了一个统一API背后的并发源。RxJava 3提供了几个可通过调度器实用程序类访问的标准调度器。
computation():在后台在固定数量的专用线程上运行大量的计算工作。大多数异步操作符将此作为默认调度程序。
io():在一组动态变化的线程上运行I/O类或阻塞操作。
single():在单个线程上按顺序和FIFO方式运行工作。
trampoline():在其中一个参与线程中以顺序和FIFO的方式运行工作，通常用于测试目的。
它们可以在所有JVM平台上使用，但是一些特定的平台，比如Android，定义了它们自己的典型调度器:AndroidSchedulers.mainThread(), SwingScheduler.instance() 或者 JavaFXSchedulers.gui()。
在RxJava中，默认的调度器运行在守护进程线程上，这意味着一旦Java主线程退出，它们都将被停止，并且可能永远不会发生后台计算。
——————————————————————————————————————————————————
Retrofit+RxJava封装：
https://segmentfault.com/a/1190000019683544
https://blog.csdn.net/cs_lwb/article/details/87987314
执行顺序：初始化Retrofit——>调用请求接口——>调用执行线程——>输出结果
——————————————————————————————————————————————————
>>>RxLifecycle：绑定Android周期
https://github.com/trello/RxLifecycle
https://www.jianshu.com/p/99cddc8c338c
implementation 'com.trello.rxlifecycle4:rxlifecycle:4.0.0'
// If you want to bind to Android-specific lifecycles
implementation 'com.trello.rxlifecycle4:rxlifecycle-android:4.0.0'
// If you want pre-written Activities and Fragments you can subclass as providers
implementation 'com.trello.rxlifecycle4:rxlifecycle-components:4.0.0'
// If you want pre-written support preference Fragments you can subclass as providers
implementation 'com.trello.rxlifecycle4:rxlifecycle-components-preference:4.0.0'
// If you want to use Android Lifecycle for providers
implementation 'com.trello.rxlifecycle4:rxlifecycle-android-lifecycle:4.0.0'
// If you want to use Kotlin syntax
implementation 'com.trello.rxlifecycle4:rxlifecycle-kotlin:4.0.0'
// If you want to use Kotlin syntax with Android Lifecycle
implementation 'com.trello.rxlifecycle4:rxlifecycle-android-lifecycle-kotlin:4.0.0'
类需要继承RxActivity, RxFragmentActivity，RxAppCompatActivity，RxFragment。
Activity:.compose(activity.bindUntilEvent(ActivityEvent.PAUSE))
Fragment:compose(fragment.bindToLifecycle())
——————————————————————————————————————————————————
>>>OkHttp无网缓存
https://blog.csdn.net/mingC0758/article/details/81678959?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase
请求拦截：
Request.Builder builder = chain.request().newBuilder(); //在原来的request的基础上修改
            if (! Util.isNetworkConnected()) {
                //无网下强制缓存
                builder.cacheControl(CacheControl.FORCE_CACHE); //等同于添加only-if-cache
            }
            Request newRequest = builder.build();
响应拦截：
Response response = chain.proceed(chain.request()).newBuilder()
                    .removeHeader("Pragma") //移除影响
                    .removeHeader("Cache-Control") //移除影响
                    .addHeader("Cache-Control", CacheControl.FORCE_CACHE.toString()).build();//强制缓存，这行很重要
——————————————————————————————————————————————————
>>>HTTPS安全认证
OkHttp中使用：https://www.jianshu.com/p/4f8832e9642c
https://github.com/square/okhttp/tree/master/okhttp-tls
HTTPS实现原理：https://blog.csdn.net/qq_20521573/article/details/79233793
获取网站证书：https://blog.csdn.net/iispring/article/details/51615631
查看服务器证书：https://www.myssl.cn/tools/check-server-cert.html
——————————————————————————————————————————————————
>>>日志输出Logger:https://github.com/orhanobut/logger
implementation 'com.orhanobut:logger:2.2.0'
——————————————————————————————————————————————————
>>>今日头条屏幕适配
原理：https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA
https://github.com/JessYanCoding/AndroidAutoSize
implementation 'me.jessyan:autosize:1.2.1'
清单文件---
<manifest>
    <application>
        <meta-data
            android:name="design_width_in_dp"
            android:value="360"/>
        <meta-data
            android:name="design_height_in_dp"
            android:value="640"/>
     </application>
</manifest>
BaseApp---
AutoSizeConfig.getInstance()
                .setBaseOnWidth(true)
                .unitsManager
                .setSupportDP(false)
                .setSupportSP(false)
                .supportSubunits = Subunits.MM
扩展适配参数--
Fragment的自定义参数功能需要先开启支持：AutoSizeConfig.getInstance().isCustomFragment = true;
当某个 Activity/Fragment  的设计图尺寸与在 AndroidManifest 中填写的全局设计图尺寸不同时，可以实现 CustomAdapt 接口扩展适配参数
public class CustomAdaptActivity extends AppCompatActivity implements CustomAdapt {

    /**
     * 是否按照宽度进行等比例适配 (为了保证在高宽比不同的屏幕上也能正常适配, 所以只能在宽度和高度之中选择一个作为基准进行适配)
     *
     * @return {@code true} 为按照宽度进行适配, {@code false} 为按照高度进行适配
     */
    @Override
    public boolean isBaseOnWidth() {
        return false;
    }

    /**
     * 这里使用 iPhone 的设计图, iPhone 的设计图尺寸为 750px * 1334px, 因为这个页面使用副单位进行布局
     * 所以可以直接以像素作为单位返回设计图的尺寸
     * <p>
     * 返回设计图上的设计尺寸
     * {@link #getSizeInDp} 须配合 {@link #isBaseOnWidth()} 使用, 规则如下:
     * 如果 {@link #isBaseOnWidth()} 返回 {@code true}, {@link #getSizeInDp} 则应该返回设计图的总宽度
     * 如果 {@link #isBaseOnWidth()} 返回 {@code false}, {@link #getSizeInDp} 则应该返回设计图的总高度
     * 如果您不需要自定义设计图上的设计尺寸, 想继续使用在 AndroidManifest 中填写的设计图尺寸, {@link #getSizeInDp} 则返回 {@code 0}
     *
     * @return 设计图上的设计尺寸
     */
    @Override
    public float getSizeInDp() {
        return 667;
    }
}
当某个 Activity/Fragment 想放弃适配，请实现 CancelAdapt 接口
public class CancelAdaptActivity extends AppCompatActivity implements CancelAdapt {
}
创建模拟设备，预览配置Preview---
很多情况下 Android Studio 提供的默认预览设备并不能完全展示我们的设计图,所以我们就需要自己创建模拟设备, 让预览效果和设计图完全一致!
AVD Manager-Create Virtual Device...-New Hardware Profile-Screen size,然后根据公式算出屏幕尺寸填入
DP： (sqrt(纵向分辨率^2+横向分辨率^2))/dpi [如:(sqrt((667*2.625)^2+(375*2.625)^2))/2.625=765.19]//2.625为我自己模拟器的dpi
PT： (sqrt(纵向分辨率^2+横向分辨率^2))/72
IN： sqrt(纵向分辨率^2+横向分辨率^2)
MM： (sqrt(纵向分辨率^2+横向分辨率^2))/25.4 [如:(sqrt(1920^2+1080^2))/25.4=86.73]
生成布局文件---
因为布局中使用的尺寸单位和设计图的不一定一样，为了避免每个数值繁冗的计算，需要在res/values下生成一个单位转换的dimens.xml。
当你布局中使用的时候即可直接引入@dimen/px[...]，这里的...就是设计图上标注的尺寸。
项目下提供了一个px转mm的demo,详见utils.XMLGenerator
private const val rootPath = "D:\\layoutroot\\values-{0}x{1}\\"//文件生成目录
private const val dw = 1080 //设计图上的屏幕宽度px
private const val dh = 1920 //设计图上的屏幕高度px
private const val Template = "<dimen name=\"px{0}\">{1}mm</dimen>\n"//xdpi和ydpi相同时仅生成一个文件
val layFile = File(path + "dimens.xml")
val sb = StringBuffer()
sb.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n")
sb.append("<resources>")
for (i in 1..dh) {
   sb.append(
   Template.replace("{0}", i.toString() + "")
       .replace("{1}", change(i / xdpi * 25.4f).toString() + "")
   )
}
sb.append("</resources>")
——————————————————————————————————————————————————
>>>全局缩放文字大小
思路：在BaseActivity重写attachBaseContext方法，将系统的fontScale重写为配置在清单文件中的缩放比例。
可结合Android 8.0 新特性：自动调整的TextView使用。该TextView中的文字会根据内容长短自动调整大小。
<?xml version="1.0" encoding="utf-8"?>
<TextView
    android:layout_width="match_parent"
    android:layout_height="200dp"
    android:autoSizeTextType="uniform"
    android:autoSizeMinTextSize="12sp"
    android:autoSizeMaxTextSize="100sp"
    android:autoSizeStepGranularity="2sp" />
autoSizeMinTextSize：字体大小范围的最小值
autoSizeMaxTextSize：字体大小范围的最大值。Min和Max的范围为12sp到100sp。
autoSizeStepGranularity：步长
autoSizeTextType：自动调整大小，none或uniform
——————————————————————————————————————————————————
>>>语言国际化
https://github.com/getActivity/MultiLanguages
implementation 'com.hjq:language:3.0'
-keep class com.hjq.language.** {*;}
需要配合values设置，多语言strings.xml创建：res右键-New-Android Resource File-Available qualifiers-Locale->>-Chosen qualifiers...，选择对应的语言，文件命名为strings.xml。
在strings.xml文件中添加的不同语言的字符串资源的名称要一样，如都是app_name。所以layout或者代码中使用到的文字不能采用硬编码，只能统一通过strings.xml动态获取。
如果不设置语种，存在对应不同语系资源文件的情况下，APP的语言会随着手机设置里的系统语言而改变。
接口中的文字转换可以和后端通过请求参数配合。
在代码中动态设置涉及到的方法：
LanguagesManager.setAppLanguage(Context context, Locale locale);//设置当前的语种（返回true需要重启App）
LanguagesManager.getAppLanguage(Context context);//获取当前的语种
LanguagesManager.setSystemLanguage(Context context);//将App语种设置为系统语种（返回true需要重启App）
LanguagesManager.getSystemLanguage();//获取系统的语种
LanguagesManager.getLanguageString(Context context, Locale locale, int stringId);//获取某个语种下的String
LanguagesManager.getLanguageResources(Context context, Locale locale);//获取某个语种下的Resources对象
为了使重启显得平滑，可以充分运用Activity跳转动画
if (restart) {
  //我们可以充分运用 Activity 跳转动画，在跳转的时候设置一个渐变的效果
  startActivity(Intent(this, ListActivity::class.java))
  overridePendingTransition(R.anim.activity_alpha_in, R.anim.activity_alpha_out)
  finish()
  //ActivityUtils.startActivityAndFinish(this, MainActivity::class.java, ActivityUtils.Anim.Fade_In_Out)
}
——————————————————————————————————————————————————