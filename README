使用技术：
Base,MVP,Kotlin,Git,SmartRefreshLayout,BaseRecyclerViewAdapterHelper,Retrofit,RxJava,HTTPS安全认证,OkHttp无网缓存,RxLifecycle,Logger,
屏幕适配,全局字体改变,语言国际化,代码混淆,Glide,RxPermissions,RxBinding,MultiDex,Dagger,
——————————————————————————————————————————————————
>>>项目结构
项目根据业务（business）功能（fct/function）划分，每一业务模块可以包含相关连的多个功能。为了将来能更好的移植到组件化开发。
建议每个业务中包含功能在10个以下，如果包含的功能太多就拆解出为多个业务模块。
每个业务单独建立一个包，每个包下面都会在细分为5个子包。分别是ui、presenter、model、di、contract。
（1）ui包是处理页面显示相关的即mvp中的view。
（2）model是处理数据相关的即mvp中的model。
（3）presenter是mvp中主持者。
（4）contract是放接口的提供给mvp使用。
（5）di包是dagger2中的注入相关的包。
业务模块包结构细分：
（1）ui包下面又划分了多个子包activity、fragment、adapter、holder、widget我们经常使用表示ui的基本覆盖了，将对应的代码放入对应的包中，有的功能不需要这么多子包，可以在用的时候在添加。
（2）model包是处理数据的包，包括3个部分。api是请求接口，entity是数据实体类，还有mvp中的model完成数据的获取工作，数据来源可以从网络、本地数据库、本地文件、SharedPreferences等方式获取。
（3）presenter包下是处理功能的业务逻辑代码编写的地方。在android开发中presenter中代码的职责划分可以很好的将activity、fragment的代码完成解耦。
（4）contract包处理存放编写mvp代码的中间接口定义的包外，还可以将功能中的常量或者功能相关的接口放到这个里边。
（5）di是依赖注入的的英文简写，是dagger2中的概念，di下边包含component、module和scope三个子包。component是存放activity的桥接的接口，module是存放提供注入对象源的包，scope是自定义的注释类。
——————————————————————————————————————————————————
>>>Kotlin
https://kotlinlang.org/docs/reference/
https://developer.android.google.cn/kotlin
——————————————————————————————————————————————————
>>>Git
git使用：https://www.cnblogs.com/einstein-2014731/p/11492637.html
git提交代码
git add .    //指定更新内容    . 表示全部更新，test.txt 表示更新指定文件
git commit -m "一些注释说明"
git push origin master

git拉取代码
$ git pull origin master

git删除文件夹/文件
可配合.gitignore提交，Module的过滤可在module下添加.gitignore文件
在包含要删除文件的目录下打开gitbash
git rm -r .idea --cached（文件夹）
git rm .idea --cached（文件）
git commit -m '删除不必要的文件'
git push origin master
——————————————————————————————————————————————————
>>>约束布局ConstraintLayout
https://www.jianshu.com/p/17ec9bd6ca8a
implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
——————————————————————————————————————————————————
>>>智能刷新库：https://github.com/scwang90/SmartRefreshLayout
如果使用 AndroidX 需要依赖 androidx.appcompat，Header依赖包建议需要使用哪个就复制哪个的源码到项目中。
implementation 'androidx.appcompat:appcompat:1.0.0'                 //必须 1.0.0 以上
implementation  'com.scwang.smart:refresh-layout-kernel:2.0.1'      //核心必须依赖
implementation  'com.scwang.smart:refresh-header-classics:2.0.1'    //经典刷新头
implementation  'com.scwang.smart:refresh-header-radar:2.0.1'       //雷达刷新头
implementation  'com.scwang.smart:refresh-header-falsify:2.0.1'     //虚拟刷新头
implementation  'com.scwang.smart:refresh-header-material:2.0.1'    //谷歌刷新头
implementation  'com.scwang.smart:refresh-header-two-level:2.0.1'   //二级刷新头
implementation  'com.scwang.smart:refresh-footer-ball:2.0.1'        //球脉冲加载
implementation  'com.scwang.smart:refresh-footer-classics:2.0.1'    //经典加载
并在 gradle.properties 中添加
android.useAndroidX=true
android.enableJetifier=true
SmartRefreshLayout 不需要添加混淆过滤代码，并且已经混淆测试通过
——————————————————————————————————————————————————
>>>强大灵活的RecyclerViewAdapter：https://github.com/CymChad/BaseRecyclerViewAdapterHelper
将JitPack存储库添加到您的构建文件中(项目根目录下build.gradle文件)
allprojects {
    repositories {
        ...
        maven { url 'https://jitpack.io' }
    }
}
添加依赖项
仅支持AndroidX
implementation 'com.github.CymChad:BaseRecyclerViewAdapterHelper:3.0.4'
此资源库自带混淆规则，并且会自动导入，正常情况下无需手动导入。
——————————————————————————————————————————————————
>>>Retrofit:
Retrofit requires at minimum Java 8+ or Android API 21+.
https://github.com/square/retrofit
https://github.com/square/okhttp
https://www.jianshu.com/p/360768def285
implementation 'com.squareup.retrofit2:retrofit:2.9.0'
implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
implementation 'com.squareup.retrofit2:converter-scalars:2.9.0'
implementation 'com.squareup.retrofit2:adapter-rxjava3:latest.version'
implementation 'com.squareup.okhttp3:logging-interceptor:4.7.2'
——————————————————————————————————————————————————
>>>RxJava：
https://github.com/ReactiveX/RxJava
http://reactivex.io/RxJava/3.x/javadoc/
https://github.com/ReactiveX/RxAndroid
RxJava3详细介绍：https://blog.csdn.net/h176nhx7/article/details/96054109
Flowable使用介绍：https://my.oschina.net/carbenson/blog/1002466
定义：是一个响应扩展的Java VM实现:一个通过使用可观察序列组合异步和基于事件的程序的库。(等同于Android中的 AsyncTask 、Handler作用)
特点：由于其基于事件流的链式调用、逻辑简洁 & 使用简单的特点，深受各大 Android开发者的欢迎。
原理：基于一种扩展的观察者模式
应用：常见用例是在后台线程上运行一些计算、网络请求，并在UI线程上显示结果(或错误)。
Flowable可看作是有背压的Observable。
implementation "io.reactivex.rxjava3:rxjava:3.0.4"
基础类：
io.reactivex.rxjava3.core.Flowable：0..N流量，支持反应流和背压
io.reactivex.rxjava3.core.Observable：0..N流动，无背压，
io.reactivex.rxjava3.core.Single：正好是1个项目的流或一个错误，
io.reactivex.rxjava3.core.Completable：没有项目但只有完成或错误信号的流程，
io.reactivex.rxjava3.core.Maybe：没有项目，恰好一项或错误的流程。
Flowable背压：
当数据流通过异步步骤运行时，每一步可能以不同的速度执行不同的事情。这类步骤通常会由于临时缓冲或需要跳过/删除数据而导致内存使用量增加，
为了避免这些步骤过于庞大，应用了所谓的backpressure，这是一种流控制形式，其中步骤可以表示它们准备处理多少项。这允许在某些情况下限制数据流的内存使用。
Flowable类被指定为支持背压操作，而Observable类被指定为非背压操作(短序列、GUI交互等)。其他类型，Single, Maybe和Completable不支持背压，也不应该支持。
Flowable流：
source.operator1().operator2().operator3().subscribeOn(Schedulers.io()).observeOn(Schedulers.single()).subscribe(consumer)
如果我们想象自己在操作器上，向左看源称为上游。向右看订阅者/使用者称为下游。
可以通过subscribeOn将计算或阻塞IO移动到其他线程。一旦数据准备好了，就可以确保通过observeOn在前台或GUI线程上处理它们。
Flowable和Observable区别：
上下游：Flowable/Subscriber,Observable/Observer
被观察者：FlowableOnSubscribe,ObservableOnSubscribe
观察者：Subscriber,Observer
取消订阅：Subscription,Disposable
create()：create(FlowableOnSubscribe,BackpressureStrategy),create(ObservableOnSubscribe)//背压策略：BackpressureStrategy.MISSING、ERROR、DROP、LATEST
Schedulers调度器
RxJava操作符并不直接与线程或ExecutorServices一起工作，而是与所谓的调度器一起工作，这些调度器抽象出了一个统一API背后的并发源。RxJava 3提供了几个可通过调度器实用程序类访问的标准调度器。
computation():在后台在固定数量的专用线程上运行大量的计算工作。大多数异步操作符将此作为默认调度程序。
io():在一组动态变化的线程上运行I/O类或阻塞操作。
single():在单个线程上按顺序和FIFO方式运行工作。
trampoline():在其中一个参与线程中以顺序和FIFO的方式运行工作，通常用于测试目的。
它们可以在所有JVM平台上使用，但是一些特定的平台，比如Android，定义了它们自己的典型调度器:AndroidSchedulers.mainThread(), SwingScheduler.instance() 或者 JavaFXSchedulers.gui()。
在RxJava中，默认的调度器运行在守护进程线程上，这意味着一旦Java主线程退出，它们都将被停止，并且可能永远不会发生后台计算。
——————————————————————————————————————————————————
Retrofit+RxJava封装：
https://segmentfault.com/a/1190000019683544
https://blog.csdn.net/cs_lwb/article/details/87987314
执行顺序：初始化Retrofit——>调用请求接口——>调用执行线程——>输出结果
Retrofit+RxJava链式调用（A接口调用完成才能开始调用B接口）：
这是一个先获取服务器线上版本号，再通过版本号获取其对应的下载链接的例子。这里【获取版本号】接口返回的版本号数据将作为【获取下载链接】接口的参数。
retrofit.getRestAPI()
                .getAppDataVersion()
                .flatMap(new Func1<AppDataVersionEntity, Observable<AppDataDownLoadEntity>>() {
                    //调用第一个接口（A接口）,获取版本号
                    @Override
                    public Observable<AppDataDownLoadEntity> call(AppDataVersionEntity appDataVersionEntity) {
                        if () {
                            //如果发生了改变，就去调用接口B
                            return retrofit.getRestAPI().getAppDataDownLoad();
                        } else {
                            //如果没发生改变，做一些逻辑
                        }
                        return null;//如果return null就继续向下执行，并不会crash
                    }
                })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Observer<AppDataDownLoadEntity>() {
                    @Override
                    public void onNext(AppDataDownLoadEntity appDataDownLoadEntity) {
                        //这是执行接口B，做一些逻辑
                    }

                    @Override
                    public void onCompleted() {
                    }

                    @Override
                    public void onError(Throwable e) {
                        e.printStackTrace();
                    }

                });
——————————————————————————————————————————————————
>>>RxLifecycle：绑定Android周期
https://github.com/trello/RxLifecycle
https://www.jianshu.com/p/99cddc8c338c
implementation 'com.trello.rxlifecycle4:rxlifecycle:4.0.0'
// If you want to bind to Android-specific lifecycles
implementation 'com.trello.rxlifecycle4:rxlifecycle-android:4.0.0'
// If you want pre-written Activities and Fragments you can subclass as providers
implementation 'com.trello.rxlifecycle4:rxlifecycle-components:4.0.0'
// If you want pre-written support preference Fragments you can subclass as providers
implementation 'com.trello.rxlifecycle4:rxlifecycle-components-preference:4.0.0'
// If you want to use Android Lifecycle for providers
implementation 'com.trello.rxlifecycle4:rxlifecycle-android-lifecycle:4.0.0'
// If you want to use Kotlin syntax
implementation 'com.trello.rxlifecycle4:rxlifecycle-kotlin:4.0.0'
// If you want to use Kotlin syntax with Android Lifecycle
implementation 'com.trello.rxlifecycle4:rxlifecycle-android-lifecycle-kotlin:4.0.0'
类需要继承RxActivity, RxFragmentActivity，RxAppCompatActivity，RxFragment。
Activity:.compose(activity.bindUntilEvent(ActivityEvent.PAUSE))
Fragment:compose(fragment.bindToLifecycle())
——————————————————————————————————————————————————
>>>OkHttp无网缓存
https://blog.csdn.net/mingC0758/article/details/81678959?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase
请求拦截：
Request.Builder builder = chain.request().newBuilder(); //在原来的request的基础上修改
            if (! Util.isNetworkConnected()) {
                //无网下强制缓存
                builder.cacheControl(CacheControl.FORCE_CACHE); //等同于添加only-if-cache
            }
            Request newRequest = builder.build();
响应拦截：
Response response = chain.proceed(chain.request()).newBuilder()
                    .removeHeader("Pragma") //移除影响
                    .removeHeader("Cache-Control") //移除影响
                    .addHeader("Cache-Control", CacheControl.FORCE_CACHE.toString()).build();//强制缓存，这行很重要
——————————————————————————————————————————————————
>>>HTTPS安全认证
OkHttp中使用：https://www.jianshu.com/p/4f8832e9642c
https://github.com/square/okhttp/tree/master/okhttp-tls
HTTPS实现原理：https://blog.csdn.net/qq_20521573/article/details/79233793
获取网站证书：https://blog.csdn.net/iispring/article/details/51615631
查看服务器证书：https://www.myssl.cn/tools/check-server-cert.html
——————————————————————————————————————————————————
>>>日志输出Logger:https://github.com/orhanobut/logger
implementation 'com.orhanobut:logger:2.2.0'
——————————————————————————————————————————————————
>>>今日头条屏幕适配
原理：https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA
https://github.com/JessYanCoding/AndroidAutoSize
implementation 'me.jessyan:autosize:1.2.1'
清单文件---
<manifest>
    <application>
        <meta-data
            android:name="design_width_in_dp"
            android:value="360"/>
        <meta-data
            android:name="design_height_in_dp"
            android:value="640"/>
     </application>
</manifest>
BaseApp---
AutoSizeConfig.getInstance()
                .setBaseOnWidth(true)
                .unitsManager
                .setSupportDP(false)
                .setSupportSP(false)
                .supportSubunits = Subunits.MM
扩展适配参数--
Fragment的自定义参数功能需要先开启支持：AutoSizeConfig.getInstance().isCustomFragment = true;
当某个 Activity/Fragment  的设计图尺寸与在 AndroidManifest 中填写的全局设计图尺寸不同时，可以实现 CustomAdapt 接口扩展适配参数
public class CustomAdaptActivity extends AppCompatActivity implements CustomAdapt {

    /**
     * 是否按照宽度进行等比例适配 (为了保证在高宽比不同的屏幕上也能正常适配, 所以只能在宽度和高度之中选择一个作为基准进行适配)
     *
     * @return {@code true} 为按照宽度进行适配, {@code false} 为按照高度进行适配
     */
    @Override
    public boolean isBaseOnWidth() {
        return false;
    }

    /**
     * 这里使用 iPhone 的设计图, iPhone 的设计图尺寸为 750px * 1334px, 因为这个页面使用副单位进行布局
     * 所以可以直接以像素作为单位返回设计图的尺寸
     * <p>
     * 返回设计图上的设计尺寸
     * {@link #getSizeInDp} 须配合 {@link #isBaseOnWidth()} 使用, 规则如下:
     * 如果 {@link #isBaseOnWidth()} 返回 {@code true}, {@link #getSizeInDp} 则应该返回设计图的总宽度
     * 如果 {@link #isBaseOnWidth()} 返回 {@code false}, {@link #getSizeInDp} 则应该返回设计图的总高度
     * 如果您不需要自定义设计图上的设计尺寸, 想继续使用在 AndroidManifest 中填写的设计图尺寸, {@link #getSizeInDp} 则返回 {@code 0}
     *
     * @return 设计图上的设计尺寸
     */
    @Override
    public float getSizeInDp() {
        return 667;
    }
}
当某个 Activity/Fragment 想放弃适配，请实现 CancelAdapt 接口
public class CancelAdaptActivity extends AppCompatActivity implements CancelAdapt {
}
创建模拟设备，预览配置Preview---
很多情况下 Android Studio 提供的默认预览设备并不能完全展示我们的设计图,所以我们就需要自己创建模拟设备, 让预览效果和设计图完全一致!
AVD Manager-Create Virtual Device...-New Hardware Profile-Screen size,然后根据公式算出屏幕尺寸填入
DP： (sqrt(纵向分辨率^2+横向分辨率^2))/dpi [如:(sqrt((667*2.625)^2+(375*2.625)^2))/2.625=765.19]//2.625为我自己模拟器的dpi
PT： (sqrt(纵向分辨率^2+横向分辨率^2))/72
IN： sqrt(纵向分辨率^2+横向分辨率^2)
MM： (sqrt(纵向分辨率^2+横向分辨率^2))/25.4 [如:(sqrt(1920^2+1080^2))/25.4=86.73]
生成布局文件---
因为布局中使用的尺寸单位和设计图的不一定一样，为了避免每个数值繁冗的计算，需要在res/values下生成一个单位转换的dimens.xml。
当你布局中使用的时候即可直接引入@dimen/px[...]，这里的...就是设计图上标注的尺寸。
项目下提供了一个px转mm的demo,详见utils.XMLGenerator
private const val rootPath = "D:\\layoutroot\\values-{0}x{1}\\"//文件生成目录
private const val dw = 1080 //设计图上的屏幕宽度px
private const val dh = 1920 //设计图上的屏幕高度px
private const val Template = "<dimen name=\"px{0}\">{1}mm</dimen>\n"//xdpi和ydpi相同时仅生成一个文件
val layFile = File(path + "dimens.xml")
val sb = StringBuffer()
sb.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n")
sb.append("<resources>")
for (i in 1..dh) {
   sb.append(
   Template.replace("{0}", i.toString() + "")
       .replace("{1}", change(i / xdpi * 25.4f).toString() + "")
   )
}
sb.append("</resources>")
——————————————————————————————————————————————————
>>>全局缩放文字大小
思路：在BaseActivity重写attachBaseContext方法，将系统的fontScale重写为配置在清单文件中的缩放比例。
<meta-data
    android:name="font_scale"
    android:value="1f" />
可结合Android 8.0 新特性：自动调整的TextView使用。该TextView中的文字会根据内容长短自动调整大小。
<?xml version="1.0" encoding="utf-8"?>
<TextView
    android:layout_width="match_parent"
    android:layout_height="200dp"
    android:autoSizeTextType="uniform"
    android:autoSizeMinTextSize="12sp"
    android:autoSizeMaxTextSize="100sp"
    android:autoSizeStepGranularity="2sp" />
autoSizeMinTextSize：字体大小范围的最小值
autoSizeMaxTextSize：字体大小范围的最大值。Min和Max的范围为12sp到100sp。
autoSizeStepGranularity：步长
autoSizeTextType：自动调整大小，none或uniform
——————————————————————————————————————————————————
>>>语言国际化
https://github.com/getActivity/MultiLanguages
implementation 'com.hjq:language:3.0'
-keep class com.hjq.language.** {*;}
需要配合values设置，多语言strings.xml创建：res右键-New-Android Resource File-Available qualifiers-Locale->>-Chosen qualifiers...，选择对应的语言，文件命名为strings.xml。
在strings.xml文件中添加的不同语言的字符串资源的名称要一样，如都是app_name。所以layout或者代码中使用到的文字不能采用硬编码，只能统一通过strings.xml动态获取。
如果不设置语种，存在对应不同语系资源文件的情况下，APP的语言会随着手机设置里的系统语言而改变。
接口中的文字转换可以和后端通过请求参数配合。
在代码中动态设置涉及到的方法：
LanguagesManager.setAppLanguage(Context context, Locale locale);//设置当前的语种（返回true需要重启App）
LanguagesManager.getAppLanguage(Context context);//获取当前的语种
LanguagesManager.setSystemLanguage(Context context);//将App语种设置为系统语种（返回true需要重启App）
LanguagesManager.getSystemLanguage();//获取系统的语种
LanguagesManager.getLanguageString(Context context, Locale locale, int stringId);//获取某个语种下的String
LanguagesManager.getLanguageResources(Context context, Locale locale);//获取某个语种下的Resources对象
为了使重启显得平滑，可以充分运用Activity跳转动画
if (restart) {
  //我们可以充分运用 Activity 跳转动画，在跳转的时候设置一个渐变的效果
  startActivity(Intent(this, ListActivity::class.java))
  overridePendingTransition(R.anim.activity_alpha_in, R.anim.activity_alpha_out)
  finish()
  //ActivityUtils.startActivityAndFinish(this, MainActivity::class.java, ActivityUtils.Anim.Fade_In_Out)
}
——————————————————————————————————————————————————
>>>代码混淆（没弄好）
https://developer.android.google.cn/studio/build/shrink-code
https://jakewharton.com/r8-optimization-lambda-groups/
https://juejin.im/post/5d1717996fb9a07eeb13bc95
——————————————————————————————————————————————————
>>>Glide（submit下载问题）
https://github.com/bumptech/glide
图片变换开源库：https://github.com/wasabeef/glide-transformations
Glide v3,v4区别：https://muyangmin.github.io/glide-docs-cn/doc/migrating.html
解析系列：https://blog.csdn.net/guolin_blog/article/details/53759439
图片加载oom解决：https://blog.csdn.net/guolin_blog/article/details/9316683
Glide是一款由Bump Technologies开发的图片加载框架，使得我们可以在Android平台上以极度简单的方式加载和展示图片。
Min Sdk Version>=14，Compile Sdk Version>=27
Support Library Version - Glide 使用的支持库版本为 27。
Glide v4 使用 注解处理器 (Annotation Processor) 来生成出一个 API，它允许应用扩展 Glide 的 API并包含各种集成库提供的组件。
基本用法：
Glide.with(fragment).load(myUrl).into(imageView);
Glide.with(fragment).clear(imageView);
实际上，当 Glide.with() 中传入的 Activity 或 Fragment 实例销毁时，Glide 会自动取消加载并回收资源。
在 ListView 或 RecyclerView 中加载图片的代码和在单独的 View 中加载完全一样。Glide 已经自动处理了 View 的复用和请求的取消。
对 url 进行 null 检验并不是必须的，如果 url 为 null，Glide 会清空 View 的内容，或者显示 placeholder Drawable 或 fallback Drawable 的内容。
——————————————————————————————————————————————————
>>>RxPermissions
https://github.com/tbruyelle/RxPermissions
Android6.0运行时危险权限，危险权限实际上才是运行时权限主要处理的对象，这些权限可能引起隐私问题或者影响其他程序运行。
权限组
    权限列表
android.permission-group.CALENDAR
    android.permission.READ_CALENDAR 允许程序读取用户的日程信息
android.permission-group.CAMERA
    android.permission.CAMERA 允许访问摄像头进行拍照
android.permission-group.CONTACTS
    android.permission.READ_CONTACTS 允许应用访问联系人通讯录信息
    android.permission.WRITE_CONTACTS 写入联系人，但不可读取
    android.permission.GET_ACCOUNTS 访问GMail账户列表
android.permission-group.LOCATION
    android.permission.ACCESS_COARSE_LOCATION 通过WiFi或移动基站的方式获取用户错略的经纬度信息，定位精度大概误差在30~1500米
    android.permission.ACCESS_FINE_LOCATION 通过GPS芯片接收卫星的定位信息，定位精度达10米以内
android.permission-group.MICROPHONE
    android.permission.RECORD_AUDIO 录制声音通过手机或耳机的麦克
android.permission-group.PHONE
    android.permission.READ_PHONE_STATE 访问电话状态
    android.permission.CALL_PHONE 允许程序从非系统拨号器里输入电话号码
    android.permission.READ_CALL_LOG 允许应用程序读取用户的通话记录
    android.permission.WRITE_CALL_LOG 允许一个程序写入（但不读取）用户的通话记录资料
    com.android.voicemail.permission.ADD_VOICEMAIL 允许应用程序添加语音邮件进入系统
    android.permission.USE_SIP 允许程序使用SIP视频服务
    android.permission.PROCESS_OUTGOING_CALLS 允许程序监视，修改或放弃播出电话
android.permission-group.SENSORS
    android.permission.BODY_SENSORS 允许从传感器，用户使用来衡量什么是他/她的身体内发生的事情，如心脏速率访问数据的应用程序
android.permission-group.SMS
    android.permission.SEND_SMS 发送短信
    android.permission.RECEIVE_SMS 接收短信
    android.permission.READ_SMS 读取短信内容
    android.permission.RECEIVE_WAP_PUSH 接收WAP PUSH信息
    android.permission.RECEIVE_MMS 接收彩信
    android.permission.READ_CELL_BROADCASTS
android.permission-group.STORAGE
    android.permission.READ_EXTERNAL_STORAGE 允许程序读取外部存储，如SD卡读文件
    android.permission.WRITE_EXTERNAL_STORAGE 允许程序写入外部存储，如SD卡上写文件
配置：
allprojects {
    repositories {
        ...
        maven { url 'https://jitpack.io' }
    }
}
dependencies {
    implementation 'com.github.tbruyelle:rxpermissions:0.12'
}
初始化：
// this是Activity或者Fragment的一个实例。在fragment中不能使用 new RxPermissions(getActivity());否则会报异常：java.lang.IllegalStateException: FragmentManager is already executing transactions.
final RxPermissions rxPermissions = new RxPermissions(this);
用法（注意申请的权限需要在manifest中有对应的声明）：
request	不支持返回权限名;返回的权限结果:全部同意时值true,否则值为false。
requestEach	会把每一个权限的名称和申请结果都列出来。
requestEachCombined	返回的权限名称:多个权限名合并成一个;返回的权限结果:全部同意时值true,否则值为false
申请多个权限(申请权限参数可为1个)：
rxPermissions
    .request(Manifest.permission.CAMERA,
             Manifest.permission.READ_PHONE_STATE)
    .subscribe(granted -> {
        if (granted) {
           // All requested permissions are granted
           //只有全部同意，才申请成功。
           //某个权限同意后，之后再申请此权限则不再弹出提示框，其他的会继续弹出。如果只有1个权限，申请成功，之后再申请此权限则不再弹出提示框。
           //不支持返回权限名;返回的权限结果:全部同意时值true,否则值为false
        } else {
           // At least one permission is denied
           //只要有一个禁止，则申请失败。
        }
    });
申请多个权限，获得详细信息：
rxPermissions
    .requestEach(Manifest.permission.CAMERA,
             Manifest.permission.READ_PHONE_STATE)
    .subscribe(permission -> { // will emit 2 Permission objects
        if (permission.granted) {
           // `permission.name` is granted !
           //同意后调用
           //会把每一个权限的名称permission.name和申请结果permission.granted都列出来。
           //if(permission.name.equals(Manifest.permission.READ_PHONE_STATE) && permission.granted){}
        } else if (permission.shouldShowRequestPermissionRationale) {
           // Denied permission without ask never again
           //禁止申请，但没有选择“以后不再询问”，以后申请权限，会继续弹出提示
        } else {
           // Denied permission with ask never again
           // Need to go to the settings
           //禁止申请，但选择“以后不再询问”，以后申请权限，不会继续弹出提示
        }
    });
申请多个权限，获取合并后的详细信息：
rxPermissions
    .requestEachCombined(Manifest.permission.CAMERA,
             Manifest.permission.READ_PHONE_STATE)
    .subscribe(permission -> { // will emit 1 Permission object
        if (permission.granted) {
           // All permissions are granted !
           //全部同意后调用
           //返回的权限名称:多个权限名合并成一个;返回的权限结果:全部同意时值true,否则值为false
        } else if (permission.shouldShowRequestPermissionRationale)
           // At least one denied permission without ask never again
           //只要有一个选择：禁止申请，但没有选择“以后不再询问”，以后申请权限，会继续弹出提示
        } else {
           // At least one denied permission with ask never again
           // Need to go to the settings
           //只要有一个选择：禁止，但选择“以后不再询问”，以后申请权限，不会继续弹出提示
        }
    });
条件触发获取权限(结合RxBinding使用)的情况：
// Must be done during an initialization phase like onCreate
RxView.clicks(findViewById(R.id.enableCamera))
    .compose(rxPermissions.ensure(Manifest.permission.CAMERA))
    .subscribe(granted -> {
        // R.id.enableCamera has been clicked
    });
——————————————————————————————————————————————————
>>>事件绑定RxBinding(Kotlin中使用问题)
https://github.com/JakeWharton/RxBinding
https://blog.csdn.net/qq_36699930/article/details/88365681
https://www.jianshu.com/p/1ad3633ef0b4
RxBinding 能够把 Android 平台的兼容包内的 UI 控件变为 Observer 对象. 可以把 UI 控件的事件当作 RxJava 中的数据流来使用。
RxBinding 可以响应式的方式来处理UI的响应问题，比如按钮的点击事件，ListView的点击事件，EditText的文本变化事件等等。
其本质上就是对控件做了监听，只是把触发事件转换成了RxJava类型的事件流。使用RxBinding相当于是对控件进行了事件绑定操作。
为什么使用：RxBinding 是对 Android View 事件的扩展, 使得开发者可以很方便的利用 RxJava 实现对 View 事件的各种操作。
RxBinding支持常用的Android自带的Weights库：
RxView（clicks）、RxTextView(textChanges)、RxAdapterView(itemClicks)、RxCompoundButton(checkChanges)、RxRadioGroup、RxSeekBar、RxPopupMenu、
RxSearchView、RxRatingBar、RxToolbar、RxAbsListView、RxAdapter、RxAutoCompleteTextView、RxToolbar、RxMenuItem、RxViewGroup等等。
引入：
需要minSdkVersion>=17
如果项目中已经导入了以下依赖包，可以直接删除了，因为RxBinding的依赖包自带rxjava和rxandroid。
implementation 'io.reactivex.rxjavaX:rxjava:'
implementation 'io.reactivex.rxjavaX:rxandroid:'
Platform bindings:
implementation 'com.jakewharton.rxbinding4:rxbinding:4.0.0'
AndroidX library bindings:
implementation 'com.jakewharton.rxbinding4:rxbinding-core:4.0.0'
implementation 'com.jakewharton.rxbinding4:rxbinding-appcompat:4.0.0'
implementation 'com.jakewharton.rxbinding4:rxbinding-drawerlayout:4.0.0'
implementation 'com.jakewharton.rxbinding4:rxbinding-leanback:4.0.0'
implementation 'com.jakewharton.rxbinding4:rxbinding-recyclerview:4.0.0'
implementation 'com.jakewharton.rxbinding4:rxbinding-slidingpanelayout:4.0.0'
implementation 'com.jakewharton.rxbinding4:rxbinding-swiperefreshlayout:4.0.0'
implementation 'com.jakewharton.rxbinding4:rxbinding-viewpager:4.0.0'
implementation 'com.jakewharton.rxbinding4:rxbinding-viewpager2:4.0.0'
Google 'material' library bindings:
implementation 'com.jakewharton.rxbinding4:rxbinding-material:4.0.0'
RxView事件——
//设置是否可见
RxView.visibility(mView).accept(mBoolean);
//设置是否可点击
RxView.clickable(mView).accept(mBoolean);
//设置是否可用
RxView.enabled(mView).accept(mBoolean);
//设置是否选中
RxView.selected(mView).accept(mBoolean);
//设置是否按下
RxView.pressed(mView).accept(mBoolean);
//设置是否激活
RxView.activated(mView).accept(mBoolean);
//View被添加
RxView.attaches(mView);
//View被添加时触发
RxView.attachEvents(mView);
//View被移除
RxView.detaches(mView);
//点击事件
RxView.clicks(mView);
//长点击事件
RxView.longClicks(mView);
//被拖拽
RxView.drags(mView);
RxView.drags(mView, new Predicate<DragEvent>());
//View被重绘
RxView.draws(mView);
//焦点发生改变
RxView.focusChanges(mView);
//全局布局改变或某View可视状态改变
RxView.globalLayouts(mView);
//悬停事件
RxView.hovers(mView);
//按键被按下
RxView.keys(mView);
//组件布局参数发生改变
RxView.layoutChangeEvents(mView)
//组件布局参数发生改变
RxView.layoutChanges(mView);
//将要绘制时
RxView.preDraws();
//滚动事件API23
RxView.scrollChangeEvents();
//状态栏和导航栏可见和隐藏
RxView.systemUiVisibilityChanges(mView);
//触摸事件
RxView.touches(mView);
其他基础组件——
//菜单
RxMenuItem.clicks(menuItem)
RxMenuItem.actionViewEvents(menuItem)
//容器View改变
RxViewGroup.changeEvents(mViewGroup)
//绝对视图滚动事件
RxAbsListView.scrollEvents(mAbsListView)
/适配器Adapter数据改变
RxAdapter.dataChanges(mAdapter)
//承载Adapter的View
RxAdapterView.itemClicks(mAdapterView < mAdapter >)
RxAdapterView.itemClickEvents(mAdapterView < mAdapter >)
RxAdapterView.itemLongClicks(mAdapterView < mAdapter >);
RxAdapterView.itemLongClicks(mAdapterView < mAdapter >, handle);
RxAdapterView.itemLongClickEvents(mAdapterView < mAdapter >);
RxAdapterView.itemLongClickEvents(mAdapterView < mAdapter >, handle);
//自动匹配完成搜索框
RxAutoCompleteTextView.itemClickEvents(mAutoCompleteTextView)
//具有两种状态的组件状态切换
RxCompoundButton.checkedChanges(mCompoundButton)
//弹出窗体点击，消失
RxPopupMenu.itemClicks(mPopupMenu)
RxPopupMenu.dismisses(mPopupMenu)
//RadioButton勾选事件
RxRadioGroup.checked(mRadioGroup).accept(true);
RxRadioGroup.checkedChanges(mRadioGroup)
//星级滚动条进度改变事件
RxRatingBar.ratingChanges(mRatingBar)
RxRatingBar.ratingChangeEvents(mRatingBar)
//搜索框
RxSearchView.query(mSearchView, isSumbmit).accept(true);
RxSearchView.queryTextChanges(mSearchView)
RxSearchView.queryTextChangeEvents(mSearchView)
//进度条进度改变
RxSeekBar.changes(mSeekBar)
RxSeekBar.changeEvents(mSeekBar)
RxSeekBar.systemChanges(mSeekBar)
RxSeekBar.userChanges(mSeekBar)
//文本改变
RxTextView.textChanges(mTextView)
RxTextView.textChangeEvents(mTextView)
RxTextView.textChangeEvents(mTextView);
RxTextView.textChangeEvents(mTextView, handle);
RxTextView.afterTextChangeEvents(mTextView, handle);
RxTextView.beforeTextChangeEvents(mTextView, handle);
//回车事件
RxTextView.editorActions(mTextView)
RxTextView.editorActions(mTextView, handle);
//Toolbar中有五个子项和导航点击事件
RxToolbar.itemClicks(mToolBar)
RxToolbar.navigationClicks(mToolBar)
举例：
点击事件：
RxView.clicks(mButton).subscribe(new Consumer<Unit>() {
            @Override
            public void accept(Unit unit) throws Exception {
                Toast.makeText(MainActivity.this, "点击按钮", Toast.LENGTH_SHORT).show();
            }
        });
防抖处理（可防止短时间内对控件的重复点击）：
RxView.clicks(mButton)
                //throttleFirst（long windowDuration，TimeUnit unit），设置一定时间内只响应首次（throttleFirst）或者末次（throttleLast）的点击事件。windowDuration为防抖时间，unit为时间单位。
                .throttleFirst(2, TimeUnit.SECONDS) //两秒钟之内只取一个点击事件，防抖操作
                .subscribe(new Consumer<Unit>() {
                    @Override
                    public void accept(Unit unit) throws Exception {
                        Toast.makeText(MainActivity.this, "点击按钮", Toast.LENGTH_SHORT).show();
                    }
                });
View隐藏或显示：
RxView.visibility(bt_1).accept(value);//等同于bt_1.setVisibility(value ? View.VISIBLE : View.GONE);
RxView.visibility(bt_1, visibilityWhenFalse).accept(value);//等同于bt_1.setVisibility(value ? View.VISIBLE : visibilityWhenFalse);
长按事件：
RxView.longClicks(mButton).subscribe(new Consumer<Unit>() {
            @Override
            public void accept(Unit unit) throws Exception {
                Toast.makeText(MainActivity.this, "按钮长按事件", Toast.LENGTH_SHORT).show();
            }
        });
点击分发多个事件（就是点击了一个按钮在多个地方收到通知）：
1.RxView.clicks(mBtnEvent).share()首先需要使用共享这个操作符
2.通过CompositeDisposable订阅多个Disposable
Observable<Unit> observable = RxView.clicks(mButton).share();
        CompositeDisposable compositeDisposable = new CompositeDisposable();

        Disposable disposable1 = observable.subscribe(new Consumer<Unit>() {
            @Override
            public void accept(Unit unit) throws Exception {
                Log.e("xyh", "accept: " + unit.toString());
            }
        });

        Disposable disposable2 = observable.subscribe(new Consumer<Unit>() {
            @Override
            public void accept(Unit unit) throws Exception {
                Log.e("xyh", "accept: " + unit.toString()); //unit.toString()默认发送的数据，可以忽略
            }
        });
        compositeDisposable.add(disposable1);
        compositeDisposable.add(disposable2);
搜索框：
RxTextView.textChanges( editText )
                .debounce( 600 , TimeUnit.MILLISECONDS )//600ms没有操作的话就执行事件
                .map(new Func1<CharSequence, String>() {
                    @Override
                    public String call(CharSequence charSequence) {
                        //get the keyword
                        String key = charSequence.toString() ;
                        return key ;
                    }
                })
                .observeOn( Schedulers.io() )
                .map(new Func1<String, List<String>>() {
                    @Override
                    public List<String> call(String keyWord ) {
                        //get list
                        List<String> dataList = new ArrayList<String>() ;
                        if ( ! TextUtils.isEmpty( keyWord )){
                            for ( String s : getData()  ) {
                                if (s != null) {
                                    if (s.contains(keyWord)) {
                                        dataList.add(s);
                                    }
                                }
                            }
                        }
                        return dataList ;
                    }
                })
                .observeOn( AndroidSchedulers.mainThread() )
                .subscribe(new Action1<List<String>>() {
                    @Override
                    public void call(List<String> strings) {
                        adapter.clear();
                        adapter.addAll( strings );
                        adapter.notifyDataSetChanged();
                    }
                }) ;
表单验证：
mEtUsername = (EditText) findViewById(R.id.et_username);
        mEtPassword = (EditText) findViewById(R.id.et_password);
        mBtnLogin = (Button) findViewById(R.id.btn_login);

        //combineLatest这个操作符:可以结合两个Observable的数据源进行输出。
        Observable.combineLatest(
                RxTextView.textChanges(mEtUsername).map(new Function<CharSequence, String>() {
                    @Override
                    public String apply(CharSequence charSequence) throws Exception {
                        return String.valueOf(charSequence);
                    }
                }), RxTextView.textChanges(mEtPassword).map(new Function<CharSequence, String>() {
                    @Override
                    public String apply(CharSequence charSequence) throws Exception {
                        return String.valueOf(charSequence);
                    }
                }), new BiFunction<String, String, Boolean>() {
                    @Override
                    public Boolean apply(String name, String password) throws Exception {
                        return name.equals("xyh") && password.equals("123");
                    }
                }).subscribe(new Consumer<Boolean>() {

            @Override
            public void accept(Boolean aBoolean) throws Exception {
                if (aBoolean) {
                    //账号和密码正确才能点击登录按钮
                    mBtnLogin.setEnabled(true);
                    RxView.clicks(mBtnLogin).subscribe(new Consumer<Unit>() {
                        @Override
                        public void accept(Unit unit) throws Exception {
                            Toast.makeText(MainActivity.this, "登录成功", Toast.LENGTH_SHORT).show();
                        }
                    });
                } else {
                    mBtnLogin.setEnabled(false);
                }
            }
        });
RxBinding和rxlifecycle 结合起来使用，可以控制控件监听的生命周期：
//点击事件，绑定活动/碎片生命周期
//onDestory（）自动销毁
Disposable disposable=RxView.clicks(bDownload)
                .compose(this.bindToLifecycle())
                .subscribe(new Consumer<Unit>() {
                    @Override
                    public void accept(Unit unit) throws Exception {
                        Toast.makeText(MainActivity.this, "点击了url="+url, Toast.LENGTH_SHORT).show();
                    }
                });
//按照生命周期需要来绑定
//这里是在onStop()方法自动停止
//ActivityEvent.STOP是activity的枚举
//FragmentEvent.STOP是fragment的枚举
Disposable disposable=RxView.clicks(bDownload)
                .compose(this.bindUntilEvent(ActivityEvent.STOP))
                .subscribe(new Consumer<Unit>() {
                    @Override
                    public void accept(Unit unit) throws Exception {
                        Toast.makeText(MainActivity.this, "点击了url="+url, Toast.LENGTH_SHORT).show();
                    }
                });
——————————————————————————————————————————————————
>>>分包MultiDex
使用和实现原理：https://blog.csdn.net/xiaxl/article/details/83089944
在Android中一个Dex文件最多存储65536个方法，也就是一个short类型的范围。但随着应用方法数量的不断增加，当Dex文件突破65536方法数量时，打包时就会抛出异常。
【Cannot fit requested classes in a single dex file (# methods: 70534 > 65536)】
Android 5.0之后，ART虚拟机天然支持MultiDex。
Android 5.0之前，系统只加载一个主dex，其它的dex采用MultiDex手段来加载。
所以使用multidex可以解决低端型机的问题
配置：
//如果是android 5.0（minSdkVersion>=21）以上的设备，只需要设置为multiDexEnabled true
defaultConfig {
    multiDexEnabled true
}
//如果需要适配android 5.0（minSdkVersion<=20）以下的设备，不仅需要设置multiDexEnabled true，还需使用 Dalvik 可执行文件分包支持库
implementation 'com.android.support:multidex:1.0.3'
而在Java代码方面，还需要继承MultiDexApplication 或者 在Application中添加
MultiDex.install(this);
——————————————————————————————————————————————————
>>>依赖项注入Dagger
https://github.com/google/dagger/
https://dagger.dev/dev-guide/android.html
https://developer.android.google.cn/training/dependency-injection
使用：https://www.jianshu.com/p/d1521732a776
https://www.jianshu.com/p/49905f81123b
区分：类依赖注入Dagger；控件依赖注入kotlin自带，butterKnife；控件事件绑定RxBinging
依赖项注入 (DI) 是一种广泛用于编程的技术，非常适用于 Android 开发。遵循 DI 的原则可以为良好的应用架构奠定基础。
依赖注入是面向对象编程的一种设计模式，其目的是为了统一管理对象，降低程序耦合，这个耦合就是类之间的依赖引起的。
实现依赖项注入可为您带来以下优势：重用代码、易于重构、易于测试。
什么是依赖项注入？类通常需要引用其他类。类可通过以下方式获取所需的对象就是依赖项注入！使用这种方法，您可以获取并提供类的依赖项，而不必让类实例自行获取。
【以参数形式提供。应用可以在构造类时提供这些依赖项，或者将这些依赖项传入需要各个依赖项的函数。例如Car 构造函数将接收 Engine 作为参数。】
Android 中有两种主要的依赖项注入方式：
构造函数注入。您将某个类的依赖项传入其构造函数。
字段注入（或 setter 注入）。某些 Android 框架类（如 Activity 和 Fragment）由系统实例化，因此无法进行构造函数注入。使用字段注入时，依赖项将在创建类后实例化。
您自行创建、提供并管理不同类的依赖项，而不依赖于库。这称为手动依赖项注入或人工依赖项注入。手动依赖项注入的方式，依赖项和类越多，手动依赖项注入就越繁琐。
有一些库通过自动执行创建和提供依赖项的过程解决此问题。它们归为两类：
基于反射的解决方案，可在运行时连接依赖项。
静态解决方案，可生成在编译时连接依赖项的代码。
Dagger 是适用于 Java、Kotlin 和 Android 的热门依赖项注入库，由 Google 进行维护。
Dagger 为您创建和管理依赖关系图，从而便于您在应用中使用 DI。它提供了完全静态和编译时依赖项，解决了基于反射的解决方案（如 Guice）的诸多开发和性能问题。
Dagger 会自动生成代码，该代码与您原本需要手动编写的代码相似。由于该代码是在编译时生成的，因此具有可追溯性，而且性能要高于其他基于反射的解决方案。
只要您声明类的依赖项并指定如何使用注释满足它们的依赖关系，Dagger 便会在构建时自动执行以上所有操作。Dagger 生成的代码与您手动编写的代码类似。
【在内部，Dagger 会创建一个对象图，然后它可以参考该图来找到提供类实例的方式。对于图中的每个类，Dagger 都会生成一个 factory 类型类，它会使用该类在内部获取该类型的实例。】
引入：
apply plugin: 'kotlin-kapt'
dependencies {
    implementation 'com.google.dagger:dagger:2.x'
    kapt 'com.google.dagger:dagger-compiler:2.x'
}
使用：
通过向构造函数添加 @Inject 注释，告知 Dagger 如何创建对应类的实例。
通过向字段添加 @Inject 注释，让 Dagger 创建对应字段的实例。但Dagger仅知道要创建，还不知道如何创建。所以还需要结合@Inject 注释构造方法，告知其如何创建。（字段注入只能在无法使用构造函数注入的 Android 框架类中使用。）
通过向类添加 @Module 注释，告知 Dagger 如何提供您的项目所不具备的类实例。需要配合内部方法，方法使用 @Provides 注释定义依赖项。
通过向接口添加 @Component 注释，让 Dagger 创建一个依赖关系图。
通过在@Component 注释的接口中提供一个函数，让该函数将请求注入的对象作为参数，告知 Dagger 要求注入依赖项的对象，此对象希望访问该图并请求注入。
使用 @Binds 告知 Dagger 接口应采用哪种实现。
使用 @Provides 告知 Dagger 如何提供您的项目所不具备的类。
在 @Component 接口内，您可以定义返回所需类的实例的函数。@Component 会让 Dagger 生成一个容器，其中应包含满足其提供的类型所需的所有依赖项。这称为 Dagger 组件。
它包含一个图，其中包括 Dagger 知道如何提供的对象及其各自的依赖项。
class UserRepository @Inject constructor(
    private val localDataSource: UserLocalDataSource,
    private val remoteDataSource: UserRemoteDataSource
) { ... }
class UserLocalDataSource @Inject constructor() { ... }
class UserRemoteDataSource @Inject constructor() { ... }
@Component
interface ApplicationGraph {
    fun repository(): UserRepository
}
val applicationGraph: ApplicationGraph = DaggerApplicationGraph.create()
val userRepository: UserRepository = applicationGraph.repository()
val userRepository2: UserRepository = applicationGraph.repository()
// Dagger 在每次收到请求时都会创建 UserRepository 的新实例。
assert(userRepository != userRepository2)
作用域限定：
//@Singleton 是 javax.inject 软件包随附的唯一一个作用域注释。
//使用构造函数注入（通过 @Inject）时，应在类中添加作用域注释；使用 Dagger 模块时，应在 @Provides 方法中添加作用域注释。
//仅在必要时使用作用域限定。过度使用作用域限定可能会对应用的运行时性能产生负面影响：只要组件在内存中，对象就会在内存中；获取限定作用域的对象的成本更高。
//当 Dagger 提供对象时，它使用 DoubleCheck 锁定，而不是 factory 类型提供程序。
构造函数注入（通过 @Inject）时——
@Singleton
@Component
interface ApplicationGraph {
    fun repository(): UserRepository
}
@Singleton
class UserRepository @Inject constructor(
    private val localDataSource: UserLocalDataSource,
    private val remoteDataSource: UserRemoteDataSource
) { ... }
//使用同一作用域注释@Singleton后，每次调用 applicationGraph.repository() 时，都会获得 UserRepository 的同一实例。
assert(userRepository == userRepository2)
使用 Dagger 模块时——
@Singleton
@Component(modules = [NetworkModule::class])
interface ApplicationComponent {
    fun inject(activity: LoginActivity)
}
@Singleton
class UserRepository @Inject constructor(
    private val localDataSource: UserLocalDataSource,
    private val remoteDataSource: UserRemoteDataSource
) { ... }
@Module
class NetworkModule {
    @Singleton
    @Provides
    fun provideLoginRetrofitService(): LoginRetrofitService { ... }
}
自定义注释：
@Scope //标注是Scope
@Documented //标记在文档
@Retention(RUNTIME) //运行时级别
public @interface ActivityScoped {
}
kotlin中:
@Scope
@Documented
@Retention(RetentionPolicy.RUNTIME)
annotation class ActivityScoped
字段注入：
注入的字段不能为私有字段。这些字段的公开范围必须至少为软件包私有。字段注入只能在无法使用构造函数注入的 Android 框架类中使用。
在kotlin中，声明的变量默认是私有的，这就需要我们单独处理一下，比如添加lateinit关键字或者添加@JvmField注解。
class LoginActivity: Activity() {
    @Inject lateinit var loginViewModel: LoginViewModel
}
注入依赖项的对象：
此函数会告知 Dagger LoginActivity 希望访问该图并请求注入。Dagger 需要满足 LoginActivity 所需的所有依赖项（LoginViewModel 具有自己的依赖项）。
如果您有请求注入的 LoginActivity 和 RegistrationActivity，则需要两种 inject() 方法，而不是涵盖这两种情况的一种通用方法。
通用 inject() 方法不会告知 Dagger 需要提供的内容。
接口中的函数可以具有任何名称，但在它们以参数形式接收要注入的对象时将其称为 inject() 是 Dagger 中的一种惯例。
@Component
interface ApplicationComponent {
    fun inject(activity: LoginActivity)
}
LoginActivity：
@Component
interface ApplicationComponent { ... }
class MyApplication: Application() {
    val appComponent = DaggerApplicationComponent.create()
}
class LoginActivity: Activity() {
    @Inject lateinit var loginViewModel: LoginViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        (applicationContext as MyApplication).appComponent.inject(this)
        super.onCreate(savedInstanceState)
    }
}
Dagger 模块：
模块是一种以语义方式封装有关如何提供对象信息的方法。
除了 @Inject 注释之外，还有一种方法可告知 Dagger 如何提供类实例，即使用 Dagger 模块中的信息。
Dagger 模块是一个带有 @Module 注释的类。您可以在其中使用 @Provides 注释定义依赖项。@Provides 方法的依赖项是该方法的参数。
可以在 Dagger 模块中使用 @Provides 注释告知 Dagger 如何提供您的项目所不具备的类（例如，Retrofit 的实例）。
// @Module informs Dagger that this class is a Dagger Module
@Module
class NetworkModule {
    @Provides
    fun provideLoginRetrofitService(): LoginRetrofitService {
        return Retrofit.Builder()
                .baseUrl("https://example.com")
                .build()
                .create(LoginService::class.java)
    }
}
为了使 Dagger 图了解此模块，您必须将其添加到 @Component 接口：
@Component(modules = [NetworkModule::class])
interface ApplicationComponent {
    ...
}
Dagger 子组件(继承并扩展)：
除了将对象作用域限定为不同的生命周期之外，创建子组件是分别封装应用的不同部分的良好做法。
根据应用流程构建应用以创建不同的 Dagger 子图有助于在内存和启动时间方面实现性能和扩容性更强的应用。
如需告知 Dagger 您希望新组件使用其他组件的一部分，方法是使用 Dagger 子组件。新组件必须是包含共享资源的组件的子组件。
子组件是继承并扩展父组件的对象图的组件。因此，父组件中提供的所有对象也将在子组件中提供。这样，子组件中的对象就可以依赖于父组件提供的对象。
如需创建子组件的实例，您需要父组件的实例。因此，父组件向子组件提供的对象的作用域仍限定为父组件。
//通过给 LoginComponent 添加 @Subcomponent 注释，创建LoginComponent 定义为 ApplicationComponent 的子组件：
// @Subcomponent annotation informs Dagger this interface is a Dagger Subcomponent
@Subcomponent
interface LoginComponent {
    fun inject(loginActivity: LoginActivity)
}
//在 LoginComponent 内定义子组件 factory，以便 ApplicationComponent 知道如何创建 LoginComponent 的实例。
@Subcomponent
interface LoginComponent {
    @Subcomponent.Factory
    interface Factory {
        fun create(): LoginComponent
    }

    fun inject(loginActivity: LoginActivity)
}
如需告知 Dagger LoginComponent 是 ApplicationComponent 的子组件，您必须通过以下方式予以指明：
1.创建新的 Dagger 模块（例如 SubcomponentsModule），并将子组件的类传递给注释的 subcomponents 属性。
@Module(subcomponents = LoginComponent::class)
class SubcomponentsModule {}
2.将新模块（即 SubcomponentsModule）添加到 ApplicationComponent：
ApplicationComponent 不再需要注入 LoginActivity，因为现在由 LoginComponent 负责注入，因此您可以从 ApplicationComponent 中移除 inject() 方法。
@Singleton
@Component(modules = [NetworkModule::class, SubcomponentsModule::class])
interface ApplicationComponent {
}
3.提供在接口中创建 LoginComponent 实例的 factory：
@Singleton
@Component(modules = [NetworkModule::class, SubcomponentsModule::class])
interface ApplicationComponent {
fun loginComponent(): LoginComponent.Factory
}
4.最后在LoginActivity使用：DaggerApplicationComponent.create().loginComponent().create().inject(this)
MVP + Dagger2：
https://github.com/googlesamples/android-architecture
https://github.com/JessYanCoding/MVPArms
在MVP框架中，所有的业务逻辑全在Presenter，换句话， presenter 持有的对象，控制着你程序的全部逻辑。
这在dagger 中，讲白了 我们只要将所有的 presenter 对象控制就可以了。
Dagger dependencies（依赖关系）：
1.创建父类module
@Module
public class FatherModule {
    @Provides
    public Father provideFather() {
        return new Father();
    }
}
2.将module加入组件并将方法暴露出来
@Component(modules = FatherModule.class)
public interface FatherComponent {
    //将内部的类暴露出来，以便于其他依赖于FatherComponent的Component调用
    Father offerFather();
}
3.子类用dependencies依赖
@Component(modules = ChildModule.class, dependencies = FatherComponent.class)
public interface ChildComponent {
    void inject(ChildActivity activity);
}
4.注入并使用
@Inject lateinit var father : Father
DaggerChildComponent.builder().fatherComponent(DaggerFatherComponent.create()).build().inject(this)
father.xxx()
------------------总结------------------
理念：模块拆分重用。
概念：
@Inject  主要是用来标注目标类的依赖和依赖的构造函数。
@Module   Module和Provides是为解决第三方类库而生的。
@Component  它是一个桥梁，一端是目标类，另一端是目标类所依赖类的实例。
includes module间互相依赖。
dependencies component间互相依赖。
scope 自定义注释，实现单例用。
构建步骤：
1.先依据不同的功能或者模块构建若干个module（零件）。
2.构建待处理业务逻辑的component（工具箱），将需要的module添加进去。
3.告诉Dagger（老板）我（类）想用这个component，让配下权限（inject(类)）。
4.我拿到工具箱（Component.inject(this)）后可以随意使用（@Inject）箱子内的零件了。
解析步骤：
1.Dagger通过@Inject找到类中具体使用的对象。
2.通过类中注入的方法inject(this)找到对应的component。
3.查找component下是否有创建该对象的方法，如果没有，去添加的modules中依次寻找。
------------------总结------------------
------------------注意------------------
只有两种注入方式，构造器注入和 module 注入。
Provide 如果是单例模式 对应的 Component 也要是单例模式。
inject(Activity act) 不能放父类，例如 inject(baseActivity) 。
component 和其依赖的 component 之间的 Scoped 不能相同。
子类 component 依赖父类的 component ，子类 component 的Scoped 要小于父类的Scoped。
@Singleton 的 @Component 只能被依赖而不能依赖任何 @Component。建议Singleton的级别是Application。
不同的 Module 不能提供相同的对象实例。
Module 中使用了自定义的 Scoped，那么对应的 component 也使用同样的Scoped。
------------------注意------------------
——————————————————————————————————————————————————
>>>依赖项注入Hit
https://developer.android.google.cn/training/dependency-injection/hilt-android
Dagger 和 Hilt 代码可以共存于同一代码库中。不过，在大多数情况下，最好使用 Hilt 管理您在 Android 上对 Dagger 的所有使用。
Hilt 通过为项目中的每个 Android 类提供容器并自动管理其生命周期，提供了一种在应用中使用 DI（依赖项注入）的标准方法。
Hilt 在热门 DI 库 Dagger 的基础上构建而成，因而能够受益于 Dagger 的编译时正确性、运行时性能、可伸缩性和 Android Studio 支持。