使用技术：
Base,MVP,Kotlin,SmartRefreshLayout,BaseRecyclerViewAdapterHelper,Retrofit,RxJava,HTTPS安全认证,OkHttp无网缓存,RxLifecycle,Logger,
屏幕适配,全局字体改变,语言国际化,代码混淆,Glide,RxPermissions,
——————————————————————————————————————————————————
>>>Kotlin：
https://kotlinlang.org/docs/reference/
https://developer.android.google.cn/kotlin
——————————————————————————————————————————————————
>>>Dagger：
https://dagger.dev/dev-guide/android.html
https://developer.android.google.cn/training/dependency-injection/dagger-android
——————————————————————————————————————————————————
>>>约束布局ConstraintLayout：https://www.jianshu.com/p/17ec9bd6ca8a
implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
——————————————————————————————————————————————————
>>>智能刷新库：https://github.com/scwang90/SmartRefreshLayout
如果使用 AndroidX 需要依赖 androidx.appcompat，Header依赖包建议需要使用哪个就复制哪个的源码到项目中。
implementation 'androidx.appcompat:appcompat:1.0.0'                 //必须 1.0.0 以上
implementation  'com.scwang.smart:refresh-layout-kernel:2.0.1'      //核心必须依赖
implementation  'com.scwang.smart:refresh-header-classics:2.0.1'    //经典刷新头
implementation  'com.scwang.smart:refresh-header-radar:2.0.1'       //雷达刷新头
implementation  'com.scwang.smart:refresh-header-falsify:2.0.1'     //虚拟刷新头
implementation  'com.scwang.smart:refresh-header-material:2.0.1'    //谷歌刷新头
implementation  'com.scwang.smart:refresh-header-two-level:2.0.1'   //二级刷新头
implementation  'com.scwang.smart:refresh-footer-ball:2.0.1'        //球脉冲加载
implementation  'com.scwang.smart:refresh-footer-classics:2.0.1'    //经典加载
并在 gradle.properties 中添加
android.useAndroidX=true
android.enableJetifier=true
SmartRefreshLayout 不需要添加混淆过滤代码，并且已经混淆测试通过
——————————————————————————————————————————————————
>>>强大灵活的RecyclerViewAdapter：https://github.com/CymChad/BaseRecyclerViewAdapterHelper
将JitPack存储库添加到您的构建文件中(项目根目录下build.gradle文件)
allprojects {
    repositories {
        ...
        maven { url 'https://jitpack.io' }
    }
}
添加依赖项
仅支持AndroidX
implementation 'com.github.CymChad:BaseRecyclerViewAdapterHelper:3.0.4'
此资源库自带混淆规则，并且会自动导入，正常情况下无需手动导入。
——————————————————————————————————————————————————
>>>Retrofit:
Retrofit requires at minimum Java 8+ or Android API 21+.
https://github.com/square/retrofit
https://github.com/square/okhttp
https://www.jianshu.com/p/360768def285
implementation 'com.squareup.retrofit2:retrofit:2.9.0'
implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
implementation 'com.squareup.retrofit2:converter-scalars:2.9.0'
implementation 'com.squareup.retrofit2:adapter-rxjava3:latest.version'
implementation 'com.squareup.okhttp3:logging-interceptor:4.7.2'
——————————————————————————————————————————————————
>>>RxJava：
https://github.com/ReactiveX/RxJava
http://reactivex.io/RxJava/3.x/javadoc/
https://github.com/ReactiveX/RxAndroid
RxJava3详细介绍：https://blog.csdn.net/h176nhx7/article/details/96054109
Flowable使用介绍：https://my.oschina.net/carbenson/blog/1002466
定义：是一个响应扩展的Java VM实现:一个通过使用可观察序列组合异步和基于事件的程序的库。(等同于Android中的 AsyncTask 、Handler作用)
特点：由于其基于事件流的链式调用、逻辑简洁 & 使用简单的特点，深受各大 Android开发者的欢迎。
原理：基于一种扩展的观察者模式
应用：常见用例是在后台线程上运行一些计算、网络请求，并在UI线程上显示结果(或错误)。
Flowable可看作是有背压的Observable。
implementation "io.reactivex.rxjava3:rxjava:3.0.4"
基础类：
io.reactivex.rxjava3.core.Flowable：0..N流量，支持反应流和背压
io.reactivex.rxjava3.core.Observable：0..N流动，无背压，
io.reactivex.rxjava3.core.Single：正好是1个项目的流或一个错误，
io.reactivex.rxjava3.core.Completable：没有项目但只有完成或错误信号的流程，
io.reactivex.rxjava3.core.Maybe：没有项目，恰好一项或错误的流程。
Flowable背压：
当数据流通过异步步骤运行时，每一步可能以不同的速度执行不同的事情。这类步骤通常会由于临时缓冲或需要跳过/删除数据而导致内存使用量增加，
为了避免这些步骤过于庞大，应用了所谓的backpressure，这是一种流控制形式，其中步骤可以表示它们准备处理多少项。这允许在某些情况下限制数据流的内存使用。
Flowable类被指定为支持背压操作，而Observable类被指定为非背压操作(短序列、GUI交互等)。其他类型，Single, Maybe和Completable不支持背压，也不应该支持。
Flowable流：
source.operator1().operator2().operator3().subscribeOn(Schedulers.io()).observeOn(Schedulers.single()).subscribe(consumer)
如果我们想象自己在操作器上，向左看源称为上游。向右看订阅者/使用者称为下游。
可以通过subscribeOn将计算或阻塞IO移动到其他线程。一旦数据准备好了，就可以确保通过observeOn在前台或GUI线程上处理它们。
Flowable和Observable区别：
上下游：Flowable/Subscriber,Observable/Observer
被观察者：FlowableOnSubscribe,ObservableOnSubscribe
观察者：Subscriber,Observer
取消订阅：Subscription,Disposable
create()：create(FlowableOnSubscribe,BackpressureStrategy),create(ObservableOnSubscribe)//背压策略：BackpressureStrategy.MISSING、ERROR、DROP、LATEST
Schedulers调度器
RxJava操作符并不直接与线程或ExecutorServices一起工作，而是与所谓的调度器一起工作，这些调度器抽象出了一个统一API背后的并发源。RxJava 3提供了几个可通过调度器实用程序类访问的标准调度器。
computation():在后台在固定数量的专用线程上运行大量的计算工作。大多数异步操作符将此作为默认调度程序。
io():在一组动态变化的线程上运行I/O类或阻塞操作。
single():在单个线程上按顺序和FIFO方式运行工作。
trampoline():在其中一个参与线程中以顺序和FIFO的方式运行工作，通常用于测试目的。
它们可以在所有JVM平台上使用，但是一些特定的平台，比如Android，定义了它们自己的典型调度器:AndroidSchedulers.mainThread(), SwingScheduler.instance() 或者 JavaFXSchedulers.gui()。
在RxJava中，默认的调度器运行在守护进程线程上，这意味着一旦Java主线程退出，它们都将被停止，并且可能永远不会发生后台计算。
——————————————————————————————————————————————————
Retrofit+RxJava封装：
https://segmentfault.com/a/1190000019683544
https://blog.csdn.net/cs_lwb/article/details/87987314
执行顺序：初始化Retrofit——>调用请求接口——>调用执行线程——>输出结果
——————————————————————————————————————————————————
>>>RxLifecycle：绑定Android周期
https://github.com/trello/RxLifecycle
https://www.jianshu.com/p/99cddc8c338c
implementation 'com.trello.rxlifecycle4:rxlifecycle:4.0.0'
// If you want to bind to Android-specific lifecycles
implementation 'com.trello.rxlifecycle4:rxlifecycle-android:4.0.0'
// If you want pre-written Activities and Fragments you can subclass as providers
implementation 'com.trello.rxlifecycle4:rxlifecycle-components:4.0.0'
// If you want pre-written support preference Fragments you can subclass as providers
implementation 'com.trello.rxlifecycle4:rxlifecycle-components-preference:4.0.0'
// If you want to use Android Lifecycle for providers
implementation 'com.trello.rxlifecycle4:rxlifecycle-android-lifecycle:4.0.0'
// If you want to use Kotlin syntax
implementation 'com.trello.rxlifecycle4:rxlifecycle-kotlin:4.0.0'
// If you want to use Kotlin syntax with Android Lifecycle
implementation 'com.trello.rxlifecycle4:rxlifecycle-android-lifecycle-kotlin:4.0.0'
类需要继承RxActivity, RxFragmentActivity，RxAppCompatActivity，RxFragment。
Activity:.compose(activity.bindUntilEvent(ActivityEvent.PAUSE))
Fragment:compose(fragment.bindToLifecycle())
——————————————————————————————————————————————————
>>>OkHttp无网缓存
https://blog.csdn.net/mingC0758/article/details/81678959?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase
请求拦截：
Request.Builder builder = chain.request().newBuilder(); //在原来的request的基础上修改
            if (! Util.isNetworkConnected()) {
                //无网下强制缓存
                builder.cacheControl(CacheControl.FORCE_CACHE); //等同于添加only-if-cache
            }
            Request newRequest = builder.build();
响应拦截：
Response response = chain.proceed(chain.request()).newBuilder()
                    .removeHeader("Pragma") //移除影响
                    .removeHeader("Cache-Control") //移除影响
                    .addHeader("Cache-Control", CacheControl.FORCE_CACHE.toString()).build();//强制缓存，这行很重要
——————————————————————————————————————————————————
>>>HTTPS安全认证
OkHttp中使用：https://www.jianshu.com/p/4f8832e9642c
https://github.com/square/okhttp/tree/master/okhttp-tls
HTTPS实现原理：https://blog.csdn.net/qq_20521573/article/details/79233793
获取网站证书：https://blog.csdn.net/iispring/article/details/51615631
查看服务器证书：https://www.myssl.cn/tools/check-server-cert.html
——————————————————————————————————————————————————
>>>日志输出Logger:https://github.com/orhanobut/logger
implementation 'com.orhanobut:logger:2.2.0'
——————————————————————————————————————————————————
>>>今日头条屏幕适配
原理：https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA
https://github.com/JessYanCoding/AndroidAutoSize
implementation 'me.jessyan:autosize:1.2.1'
清单文件---
<manifest>
    <application>
        <meta-data
            android:name="design_width_in_dp"
            android:value="360"/>
        <meta-data
            android:name="design_height_in_dp"
            android:value="640"/>
     </application>
</manifest>
BaseApp---
AutoSizeConfig.getInstance()
                .setBaseOnWidth(true)
                .unitsManager
                .setSupportDP(false)
                .setSupportSP(false)
                .supportSubunits = Subunits.MM
扩展适配参数--
Fragment的自定义参数功能需要先开启支持：AutoSizeConfig.getInstance().isCustomFragment = true;
当某个 Activity/Fragment  的设计图尺寸与在 AndroidManifest 中填写的全局设计图尺寸不同时，可以实现 CustomAdapt 接口扩展适配参数
public class CustomAdaptActivity extends AppCompatActivity implements CustomAdapt {

    /**
     * 是否按照宽度进行等比例适配 (为了保证在高宽比不同的屏幕上也能正常适配, 所以只能在宽度和高度之中选择一个作为基准进行适配)
     *
     * @return {@code true} 为按照宽度进行适配, {@code false} 为按照高度进行适配
     */
    @Override
    public boolean isBaseOnWidth() {
        return false;
    }

    /**
     * 这里使用 iPhone 的设计图, iPhone 的设计图尺寸为 750px * 1334px, 因为这个页面使用副单位进行布局
     * 所以可以直接以像素作为单位返回设计图的尺寸
     * <p>
     * 返回设计图上的设计尺寸
     * {@link #getSizeInDp} 须配合 {@link #isBaseOnWidth()} 使用, 规则如下:
     * 如果 {@link #isBaseOnWidth()} 返回 {@code true}, {@link #getSizeInDp} 则应该返回设计图的总宽度
     * 如果 {@link #isBaseOnWidth()} 返回 {@code false}, {@link #getSizeInDp} 则应该返回设计图的总高度
     * 如果您不需要自定义设计图上的设计尺寸, 想继续使用在 AndroidManifest 中填写的设计图尺寸, {@link #getSizeInDp} 则返回 {@code 0}
     *
     * @return 设计图上的设计尺寸
     */
    @Override
    public float getSizeInDp() {
        return 667;
    }
}
当某个 Activity/Fragment 想放弃适配，请实现 CancelAdapt 接口
public class CancelAdaptActivity extends AppCompatActivity implements CancelAdapt {
}
创建模拟设备，预览配置Preview---
很多情况下 Android Studio 提供的默认预览设备并不能完全展示我们的设计图,所以我们就需要自己创建模拟设备, 让预览效果和设计图完全一致!
AVD Manager-Create Virtual Device...-New Hardware Profile-Screen size,然后根据公式算出屏幕尺寸填入
DP： (sqrt(纵向分辨率^2+横向分辨率^2))/dpi [如:(sqrt((667*2.625)^2+(375*2.625)^2))/2.625=765.19]//2.625为我自己模拟器的dpi
PT： (sqrt(纵向分辨率^2+横向分辨率^2))/72
IN： sqrt(纵向分辨率^2+横向分辨率^2)
MM： (sqrt(纵向分辨率^2+横向分辨率^2))/25.4 [如:(sqrt(1920^2+1080^2))/25.4=86.73]
生成布局文件---
因为布局中使用的尺寸单位和设计图的不一定一样，为了避免每个数值繁冗的计算，需要在res/values下生成一个单位转换的dimens.xml。
当你布局中使用的时候即可直接引入@dimen/px[...]，这里的...就是设计图上标注的尺寸。
项目下提供了一个px转mm的demo,详见utils.XMLGenerator
private const val rootPath = "D:\\layoutroot\\values-{0}x{1}\\"//文件生成目录
private const val dw = 1080 //设计图上的屏幕宽度px
private const val dh = 1920 //设计图上的屏幕高度px
private const val Template = "<dimen name=\"px{0}\">{1}mm</dimen>\n"//xdpi和ydpi相同时仅生成一个文件
val layFile = File(path + "dimens.xml")
val sb = StringBuffer()
sb.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n")
sb.append("<resources>")
for (i in 1..dh) {
   sb.append(
   Template.replace("{0}", i.toString() + "")
       .replace("{1}", change(i / xdpi * 25.4f).toString() + "")
   )
}
sb.append("</resources>")
——————————————————————————————————————————————————
>>>全局缩放文字大小
思路：在BaseActivity重写attachBaseContext方法，将系统的fontScale重写为配置在清单文件中的缩放比例。
<meta-data
    android:name="font_scale"
    android:value="1f" />
可结合Android 8.0 新特性：自动调整的TextView使用。该TextView中的文字会根据内容长短自动调整大小。
<?xml version="1.0" encoding="utf-8"?>
<TextView
    android:layout_width="match_parent"
    android:layout_height="200dp"
    android:autoSizeTextType="uniform"
    android:autoSizeMinTextSize="12sp"
    android:autoSizeMaxTextSize="100sp"
    android:autoSizeStepGranularity="2sp" />
autoSizeMinTextSize：字体大小范围的最小值
autoSizeMaxTextSize：字体大小范围的最大值。Min和Max的范围为12sp到100sp。
autoSizeStepGranularity：步长
autoSizeTextType：自动调整大小，none或uniform
——————————————————————————————————————————————————
>>>语言国际化
https://github.com/getActivity/MultiLanguages
implementation 'com.hjq:language:3.0'
-keep class com.hjq.language.** {*;}
需要配合values设置，多语言strings.xml创建：res右键-New-Android Resource File-Available qualifiers-Locale->>-Chosen qualifiers...，选择对应的语言，文件命名为strings.xml。
在strings.xml文件中添加的不同语言的字符串资源的名称要一样，如都是app_name。所以layout或者代码中使用到的文字不能采用硬编码，只能统一通过strings.xml动态获取。
如果不设置语种，存在对应不同语系资源文件的情况下，APP的语言会随着手机设置里的系统语言而改变。
接口中的文字转换可以和后端通过请求参数配合。
在代码中动态设置涉及到的方法：
LanguagesManager.setAppLanguage(Context context, Locale locale);//设置当前的语种（返回true需要重启App）
LanguagesManager.getAppLanguage(Context context);//获取当前的语种
LanguagesManager.setSystemLanguage(Context context);//将App语种设置为系统语种（返回true需要重启App）
LanguagesManager.getSystemLanguage();//获取系统的语种
LanguagesManager.getLanguageString(Context context, Locale locale, int stringId);//获取某个语种下的String
LanguagesManager.getLanguageResources(Context context, Locale locale);//获取某个语种下的Resources对象
为了使重启显得平滑，可以充分运用Activity跳转动画
if (restart) {
  //我们可以充分运用 Activity 跳转动画，在跳转的时候设置一个渐变的效果
  startActivity(Intent(this, ListActivity::class.java))
  overridePendingTransition(R.anim.activity_alpha_in, R.anim.activity_alpha_out)
  finish()
  //ActivityUtils.startActivityAndFinish(this, MainActivity::class.java, ActivityUtils.Anim.Fade_In_Out)
}
——————————————————————————————————————————————————
>>>代码混淆（没弄好）
https://developer.android.google.cn/studio/build/shrink-code
https://jakewharton.com/r8-optimization-lambda-groups/
https://juejin.im/post/5d1717996fb9a07eeb13bc95
——————————————————————————————————————————————————
>>>Glide（submit下载问题）
https://github.com/bumptech/glide
图片变换开源库：https://github.com/wasabeef/glide-transformations
Glide v3,v4区别：https://muyangmin.github.io/glide-docs-cn/doc/migrating.html
解析系列：https://blog.csdn.net/guolin_blog/article/details/53759439
图片加载oom解决：https://blog.csdn.net/guolin_blog/article/details/9316683
Glide是一款由Bump Technologies开发的图片加载框架，使得我们可以在Android平台上以极度简单的方式加载和展示图片。
Min Sdk Version>=14，Compile Sdk Version>=27
Support Library Version - Glide 使用的支持库版本为 27。
Glide v4 使用 注解处理器 (Annotation Processor) 来生成出一个 API，它允许应用扩展 Glide 的 API并包含各种集成库提供的组件。
基本用法：
Glide.with(fragment).load(myUrl).into(imageView);
Glide.with(fragment).clear(imageView);
实际上，当 Glide.with() 中传入的 Activity 或 Fragment 实例销毁时，Glide 会自动取消加载并回收资源。
在 ListView 或 RecyclerView 中加载图片的代码和在单独的 View 中加载完全一样。Glide 已经自动处理了 View 的复用和请求的取消。
对 url 进行 null 检验并不是必须的，如果 url 为 null，Glide 会清空 View 的内容，或者显示 placeholder Drawable 或 fallback Drawable 的内容。
——————————————————————————————————————————————————
>>>RxPermissions
https://github.com/tbruyelle/RxPermissions
Android6.0运行时危险权限，危险权限实际上才是运行时权限主要处理的对象，这些权限可能引起隐私问题或者影响其他程序运行。
权限组 权限列表
android.permission-group.CALENDAR
    android.permission.READ_CALENDAR 允许程序读取用户的日程信息
android.permission-group.CAMERA
    android.permission.CAMERA 允许访问摄像头进行拍照
android.permission-group.CONTACTS
    android.permission.READ_CONTACTS 允许应用访问联系人通讯录信息
    android.permission.WRITE_CONTACTS 写入联系人，但不可读取
    android.permission.GET_ACCOUNTS 访问GMail账户列表
android.permission-group.LOCATION
    android.permission.ACCESS_COARSE_LOCATION 通过WiFi或移动基站的方式获取用户错略的经纬度信息，定位精度大概误差在30~1500米
    android.permission.ACCESS_FINE_LOCATION 通过GPS芯片接收卫星的定位信息，定位精度达10米以内
android.permission-group.MICROPHONE
    android.permission.RECORD_AUDIO 录制声音通过手机或耳机的麦克
android.permission-group.PHONE
    android.permission.READ_PHONE_STATE 访问电话状态
    android.permission.CALL_PHONE 允许程序从非系统拨号器里输入电话号码
    android.permission.READ_CALL_LOG 允许应用程序读取用户的通话记录
    android.permission.WRITE_CALL_LOG 允许一个程序写入（但不读取）用户的通话记录资料
    com.android.voicemail.permission.ADD_VOICEMAIL 允许应用程序添加语音邮件进入系统
    android.permission.USE_SIP 允许程序使用SIP视频服务
    android.permission.PROCESS_OUTGOING_CALLS 允许程序监视，修改或放弃播出电话
android.permission-group.SENSORS
    android.permission.BODY_SENSORS 允许从传感器，用户使用来衡量什么是他/她的身体内发生的事情，如心脏速率访问数据的应用程序
android.permission-group.SMS
    android.permission.SEND_SMS 发送短信
    android.permission.RECEIVE_SMS 接收短信
    android.permission.READ_SMS 读取短信内容
    android.permission.RECEIVE_WAP_PUSH 接收WAP PUSH信息
    android.permission.RECEIVE_MMS 接收彩信
    android.permission.READ_CELL_BROADCASTS
android.permission-group.STORAGE
    android.permission.READ_EXTERNAL_STORAGE 允许程序读取外部存储，如SD卡读文件
    android.permission.WRITE_EXTERNAL_STORAGE 允许程序写入外部存储，如SD卡上写文件
配置：
allprojects {
    repositories {
        ...
        maven { url 'https://jitpack.io' }
    }
}
dependencies {
    implementation 'com.github.tbruyelle:rxpermissions:0.12'
}
初始化：
// this是Activity或者Fragment的一个实例。在fragment中不能使用 new RxPermissions(getActivity());否则会报异常：java.lang.IllegalStateException: FragmentManager is already executing transactions.
final RxPermissions rxPermissions = new RxPermissions(this);
用法（注意申请的权限需要在manifest中有对应的声明）：
request	不支持返回权限名;返回的权限结果:全部同意时值true,否则值为false。
requestEach	会把每一个权限的名称和申请结果都列出来。
requestEachCombined	返回的权限名称:多个权限名合并成一个;返回的权限结果:全部同意时值true,否则值为false
申请多个权限(申请权限参数可为1个)：
rxPermissions
    .request(Manifest.permission.CAMERA,
             Manifest.permission.READ_PHONE_STATE)
    .subscribe(granted -> {
        if (granted) {
           // All requested permissions are granted
           //只有全部同意，才申请成功。
           //某个权限同意后，之后再申请此权限则不再弹出提示框，其他的会继续弹出。如果只有1个权限，申请成功，之后再申请此权限则不再弹出提示框。
           //不支持返回权限名;返回的权限结果:全部同意时值true,否则值为false
        } else {
           // At least one permission is denied
           //只要有一个禁止，则申请失败。
        }
    });
申请多个权限，获得详细信息：
rxPermissions
    .requestEach(Manifest.permission.CAMERA,
             Manifest.permission.READ_PHONE_STATE)
    .subscribe(permission -> { // will emit 2 Permission objects
        if (permission.granted) {
           // `permission.name` is granted !
           //同意后调用
           //会把每一个权限的名称permission.name和申请结果permission.granted都列出来。
           //if(permission.name.equals(Manifest.permission.READ_PHONE_STATE) && permission.granted){}
        } else if (permission.shouldShowRequestPermissionRationale) {
           // Denied permission without ask never again
           //禁止申请，但没有选择“以后不再询问”，以后申请权限，会继续弹出提示
        } else {
           // Denied permission with ask never again
           // Need to go to the settings
           //禁止申请，但选择“以后不再询问”，以后申请权限，不会继续弹出提示
        }
    });
申请多个权限，获取合并后的详细信息：
rxPermissions
    .requestEachCombined(Manifest.permission.CAMERA,
             Manifest.permission.READ_PHONE_STATE)
    .subscribe(permission -> { // will emit 1 Permission object
        if (permission.granted) {
           // All permissions are granted !
           //全部同意后调用
           //返回的权限名称:多个权限名合并成一个;返回的权限结果:全部同意时值true,否则值为false
        } else if (permission.shouldShowRequestPermissionRationale)
           // At least one denied permission without ask never again
           //只要有一个选择：禁止申请，但没有选择“以后不再询问”，以后申请权限，会继续弹出提示
        } else {
           // At least one denied permission with ask never again
           // Need to go to the settings
           //只要有一个选择：禁止，但选择“以后不再询问”，以后申请权限，不会继续弹出提示
        }
    });
条件触发获取权限(结合RxBinding使用)的情况：
// Must be done during an initialization phase like onCreate
RxView.clicks(findViewById(R.id.enableCamera))
    .compose(rxPermissions.ensure(Manifest.permission.CAMERA))
    .subscribe(granted -> {
        // R.id.enableCamera has been clicked
    });
——————————————————————————————————————————————————